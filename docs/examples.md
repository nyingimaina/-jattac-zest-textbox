<!-- docs/examples.md -->
[‚¨ÖÔ∏è Previous: README.md](./../README.md) | [Next: Features Showcase ‚û°Ô∏è](./features.md)

# üìñ The Cookbook: Step-by-Step Examples

Welcome to the `ZestTextbox` Cookbook! This is your primary guide to learning how to leverage the full power and flexibility of `ZestTextbox` to build delightful and robust input experiences in your React applications.

Each "recipe" below solves a common real-world problem, guiding you from basic usage to advanced customizations. As you explore, you'll find links to other documentation sections (our "spokes") for deeper dives into specific APIs or configuration options.

---

## Table of Contents
<!-- TOC auto-generated by Gemini CLI, please do not edit -->
<!-- TOC END -->

---

### Recipe 1: Basic Text Input (Hello World)

**Problem:** You need a standard text input field, but want it to be aesthetically pleasing, accessible, and easily extendable without much effort.

**Solution:** `ZestTextbox` acts as a drop-in replacement for standard HTML `<input type="text" />` elements, automatically providing enhanced styling and foundational features.

```jsx
import React from 'react';
import ZestTextbox from 'jattac.libs.web.zest-textbox';

const BasicTextInputExample = () => {
  return (
    <div style={{ padding: '2rem', maxWidth: '400px', margin: '0 auto' }}>
      <h2>Basic Text Input</h2>
      <ZestTextbox placeholder="Enter your name" />
    </div>
  );
};

export default BasicTextInputExample;
```

---

### Recipe 2: Password Input with Visibility Toggle

**Problem:** You need a password input field that allows users to easily toggle visibility, enhancing both security (by preventing shoulder-surfing errors) and usability (by allowing users to verify their input).

**Solution:** Simply set the `type` prop to `"password"`. `ZestTextbox` automatically integrates a toggle button to show/hide the password.

```jsx
import React from 'react';
import ZestTextbox from 'jattac.libs.web.zest-textbox';

const PasswordExample = () => {
  return (
    <div style={{ padding: '2rem', maxWidth: '400px', margin: '0 auto' }}>
      <h2>Password Input</h2>
      <ZestTextbox type="password" placeholder="Enter your password" />
    </div>
  );
};

export default PasswordExample;
```

---

### Recipe 3: Character Counter & Progress Bar

**Problem:** You want to provide users with immediate visual feedback on their input length, especially when a `maxLength` is enforced. This helps manage expectations and improves the user experience for constrained inputs.

**Solution:** Set the `maxLength` prop and enable `showProgressBar` and `animatedCounter` within the `zest` prop.

```jsx
import React from 'react';
import ZestTextbox from 'jattac.libs.web.zest-textbox';

const CounterExample = () => {
  const [text, setText] = React.useState('');
  return (
    <div style={{ padding: '2rem', maxWidth: '400px', margin: '0 auto' }}>
      <h2>Character Counter & Progress Bar</h2>
      <ZestTextbox
        maxLength={100}
        placeholder="What's on your mind? (max 100 chars)"
        value={text}
        zest={{
          showProgressBar: true,
          animatedCounter: true,
          onTextChanged: setText,
        }}
      />
    </div>
  );
};

export default CounterExample;
```

---

### Recipe 4: Numeric and Semantic Inputs

**Problem:** You need to restrict input to specific numeric formats (e.g., integers, decimals, currency) and automatically handle parsing to a `number` type, while also conveying the semantic intent of the field.

**Solution:** Use `type="number"` for intelligent filtering that allows only digits, a single decimal point, and a single leading negative sign. The `onTextChanged` callback will receive a `number | undefined`. For clearer intent and potential future enhancements, you can also use semantic types like `type="currency"` or `type="percentage"`.

```jsx
import React from 'react';
import ZestTextbox from 'jattac.libs.web.zest-textbox';

const NumericExample = () => {
  const [age, setAge] = React.useState<number | undefined>(undefined);
  const [price, setPrice] = React.useState<number | undefined>(undefined);

  const currencyFormatter = (val: string) => {
    const num = parseFloat(val);
    return num === undefined ? '' : `${num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
  };

  return (
    <div style={{ padding: '2rem', maxWidth: '400px', margin: '0 auto' }}>
      <h2>Numeric and Semantic Inputs</h2>
      <p>Age (type="number"): {age === undefined ? 'N/A' : age}</p>
      <ZestTextbox
        type="number"
        placeholder="Enter your age"
        zest={{ onTextChanged: setAge }}
      />
      <br /><br />
      <p>Price (type="currency"): {price === undefined ? 'N/A' : price}</p>
      <ZestTextbox
        type="currency"
        placeholder="Enter a price"
        defaultValue="19.99"
        zest={{
          onTextChanged: setPrice,
          helperTextConfig: {
            formatter: currencyFormatter,
            templater: (formatted) => `Formatted: ${formatted}`
          }
        }}
      />
    </div>
  );
};

export default NumericExample;
```

---

### Recipe 5: Custom Parser & Validator

**Problem:** The built-in input types and validators don't cover all your specific data input needs (e.g., a positive integer, a custom date format, or a specific ID structure). You need fine-grained control over how input is processed and validated.

**Solution:** Define your own `parser` and `validator` functions within the `zest` prop. These functions receive the raw input string (for `parser`) or the parsed value (for `validator`) along with the `inputType` for contextual logic.

```jsx
import React from 'react';
import ZestTextbox, { InputParser, InputValidator, HtmlInputType } from 'jattac.libs.web.zest-textbox';

// Custom parser for positive integers
const positiveIntegerParser: InputParser<number> = (value: string, inputType?: HtmlInputType) => {
  if (inputType === 'number') {
    const parsed = parseInt(value, 10);
    return isNaN(parsed) ? undefined : parsed;
  }
  return undefined;
};

// Custom validator for positive integers
const positiveIntegerValidator: InputValidator<number> = (parsedValue: number | undefined, inputType?: HtmlInputType) => {
  if (inputType === 'number') {
    if (parsedValue === undefined) {
      return "Please enter a valid integer.";
    }
    if (parsedValue <= 0) {
      return "Value must be a positive integer.";
    }
  }
  return true;
};

const CustomNumericParserValidatorExample = () => {
  const [quantity, setQuantity] = React.useState<number | undefined>(undefined);

  return (
    <div style={{ padding: '2rem', maxWidth: '400px', margin: '0 auto' }}>
      <h2>Custom Numeric Parser & Validator</h2>
      <p>Quantity: {quantity === undefined ? 'N/A' : quantity}</p>
      <ZestTextbox
        type="number"
        placeholder="Enter positive quantity"
        zest={{
          onTextChanged: setQuantity,
          parser: positiveIntegerParser,
          validator: positiveIntegerValidator,
        }}
      />
    </div>
  );
};

export default CustomNumericParserValidatorExample;
```

---

### Recipe 6: Sizing

**Problem:** You need to control the visual size of the textbox to fit different UI contexts, such as a compact search bar, a standard form field, or a prominent title input.

**Solution:** Use the `zSize` property within the `zest` prop to specify `"sm"` (small), `"md"` (medium, default), or `"lg"` (large).

```jsx
import React from 'react';
import ZestTextbox from 'jattac.libs.web.zest-textbox';

const SizingExample = () => {
  return (
    <div style={{ padding: '2rem', maxWidth: '400px', margin: '0 auto' }}>
      <h2>Sizing</h2>
      <ZestTextbox zest={{ zSize: "sm" }} placeholder="Small" />
      <br /><br />
      <ZestTextbox zest={{ zSize: "md" }} placeholder="Medium (default)" />
      <br /><br />
      <ZestTextbox zest={{ zSize: "lg" }} placeholder="Large" />
    </div>
  );
};

export default SizingExample;
```

---

### Recipe 7: Theming (Light/Dark/System)

**Problem:** Your application supports multiple themes (e.g., light mode, dark mode) or you want the input to automatically adapt to the user's system preferences, ensuring a consistent and pleasant user experience.

**Solution:** Use the `theme` property within the `zest` prop. Set it to `"light"`, `"dark"`, or `"system"` (default) to force a specific theme or enable automatic adaptation.

```jsx
import React from 'react';
import ZestTextbox from 'jattac.libs.web.zest-textbox';

const ThemingExample = () => {
  return (
    <div style={{ padding: '2rem', maxWidth: '400px', margin: '0 auto' }}>
      <h2>Theming</h2>
      <ZestTextbox zest={{ theme: "light" }} placeholder="Light Mode" />
      <br /><br />
      <ZestTextbox zest={{ theme: "dark" }} placeholder="Dark Mode" />
      <br /><br />
      <ZestTextbox zest={{ theme: "system" }} placeholder="System Theme (default)" />
    </div>
  );
};

export default ThemingExample;
```

---

### Recipe 8: Multiline Textarea

**Problem:** You need a larger input area for longer text entries, such as comments, descriptions, or messages, rather than a single-line input.

**Solution:** Set `isMultiline` to `true` within the `zest` prop. You can also specify the `rows` prop, just like a standard `<textarea>`.

```jsx
import React from 'react';
import ZestTextbox from 'jattac.libs.web.zest-textbox';

const MultilineExample = () => {
  return (
    <div style={{ padding: '2rem', maxWidth: '400px', margin: '0 auto' }}>
      <h2>Multiline Textarea</h2>
      <ZestTextbox
        zest={{ isMultiline: true }}
        placeholder="Type a longer message here..."
        rows={4}
      />
    </div>
  );
};

export default MultilineExample;
```

---

### Recipe 9: Dynamic Helper Text with Advanced Formatting

**Problem:** You need to display rich, dynamic helper text below the input field that provides context-aware information, formatting, or even interactive elements based on the user's input or component state.

**Solution:** Utilize the `helperTextConfig` property within the `zest` prop. Its `formatter` and `templater` functions receive a powerful `ZestContext` object, giving you access to the raw `value`, `parsedValue`, and the component's `props` for highly customized displays.

```jsx
import React from 'react';
import ZestTextbox, { ZestContext } from 'jattac.libs.web.zest-textbox';

const HelperTextExample = () => {
  const [amount, setAmount] = React.useState<number | undefined>(undefined);
  const [message, setMessage] = React.useState('');

  const currencyFormatter = (context: ZestContext<number>) => {
    const num = context.parsedValue;
    return num === undefined ? '' : `${num.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 })}`;
  };

  const messageTemplater = (formattedValue: string, context: ZestContext<string>) => (
    <span style={{ color: context.value.length > (context.props.maxLength || 0) * 0.8 ? 'orange' : 'green' }}>
      Length: {context.value.length} / {context.props.maxLength || '‚àû'}
    </span>
  );

  return (
    <div style={{ padding: '2rem', maxWidth: '400px', margin: '0 auto' }}>
      <h2>Helper Text</h2>
      <ZestTextbox
        type="currency"
        placeholder="Enter amount"
        zest={{
          onTextChanged: setAmount,
          helperTextConfig: {
            formatter: currencyFormatter,
            templater: (formatted, context) => (
              <span>
                Formatted: <strong>{formatted || 'N/A'}</strong> (Type: {context.props.type})
              </span>
            ),
          },
        }}
      />
      <br /><br />
      <ZestTextbox
        maxLength={50}
        placeholder="Type something (max 50 chars)..."
        zest={{
          onTextChanged: setMessage,
          helperTextConfig: {
            templater: messageTemplater,
          },
        }}
      />
    </div>
  );
};

export default HelperTextExample;
```

---

### Recipe 10: Full Width Stretching

**Problem:** You need the textbox to dynamically adapt to the available width of its parent container, ensuring it fits seamlessly into various form layouts or page sections.

**Solution:** Set `stretch` to `true` within the `zest` prop. This will make the component take up 100% of the width of its parent.

```jsx
import React from 'react';
import ZestTextbox from 'jattac.libs.web.zest-textbox';

const StretchExample = () => {
  return (
    <div style={{ padding: '2rem', maxWidth: '400px', margin: '0 auto', border: '1px dashed #ccc' }}>
      <h2>Full Width Stretching</h2>
      <ZestTextbox zest={{ stretch: true }} placeholder="I stretch to full width!" />
    </div>
  );
};

export default StretchExample;
```

---

### Recipe 11: Helper Text Positioning to Prevent Layout Shift

**Problem:** Dynamic helper text appearing and disappearing can cause surrounding UI elements to "jump," leading to a jarring user experience. You want to reserve space for helper text to prevent these layout shifts.

**Solution:** Use the `helperTextPositioning` prop. Set it to `"reserved"` to ensure the space for the helper text is always present, preventing layout shifts. Alternatively, `"absolute"` (the default) allows the helper text to float, which might cause overlap but uses less vertical space when hidden.

```jsx
import React from 'react';
import ZestTextbox from 'jattac.libs.web.zest-textbox';

const HelperTextPositioningExample = () => {
  const [textReserved, setTextReserved] = React.useState('');
  const [textAbsolute, setTextAbsolute] = React.useState('');

  return (
    <div style={{ padding: '2rem', maxWidth: '400px', margin: '0 auto', border: '1px dashed #ccc' }}>
      <h2>Helper Text Positioning</h2>

      <h3>Reserved Space (prevents layout shift)</h3>
      <ZestTextbox
        maxLength={30}
        placeholder="Type here (reserved space)"
        zest={{
          onTextChanged: setTextReserved,
          helperTextPositioning: "reserved",
          helperTextConfig: {
            templater: () => (
              <span>This helper text reserves space.</span>
            ),
          },
        }}
      />
      <p style={{ marginTop: '2rem' }}>Content below the reserved textbox.</p> {/* This content won't jump */}

      <br /><br />

      <h3>Absolute Positioning (may cause overlap)</h3>
      <ZestTextbox
        maxLength={30}
        placeholder="Type here (absolute position)"
        zest={{
          onTextChanged: setTextAbsolute,
          helperTextPositioning: "absolute", // Default, but explicit here
          helperTextConfig: {
            templater: () => (
              <span>This helper text floats.</span>
            ),
          },
        }}
      />
      <p style={{ marginTop: '0.5rem' }>Content below the absolute textbox.</p> {/* This content might be overlapped */}

    </div>
  );
};

export default HelperTextPositioningExample;
```

---

[‚¨ÖÔ∏è Previous: README.md](./../README.md) | [Next: Features Showcase ‚û°Ô∏è](./features.md)
