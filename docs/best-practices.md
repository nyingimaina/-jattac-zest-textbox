<!-- docs/best-practices.md -->
[‚¨ÖÔ∏è Previous: Contributor's Guide](./development.md) | [Next: Upgrade Path ‚û°Ô∏è](./breaking-changes.md)

# üí° Best Practices & Developer Insights

This page provides essential best practices and deeper insights for developers working with `ZestTextbox`. Adhering to these guidelines will help you build robust, performant, and maintainable applications, avoiding common pitfalls.

---

## Table of Contents
<!-- TOC auto-generated by Gemini CLI, please do not edit -->
<!-- TOC END -->

---

## Memoizing Function Props: Ensuring Performance and Stability

A common source of unnecessary re-renders and potential performance issues (or even infinite loops in certain complex scenarios) stems from passing unmemoized function props to child components in React. `ZestTextbox`, with its reactive configuration system, is particularly sensitive to this.

**The Problem:**

When you define a function directly within a component's render method or functional component body (e.g., as an inline arrow function), a *new function instance* is created on every single re-render of that parent component. If this new function instance is passed down as a prop, the child component (like `ZestTextbox`) will perceive it as a "changed" prop, even if the function's logic is identical. This "change" can trigger a cascade of re-renders in the child, leading to performance degradation.

In `ZestTextbox`'s case, properties within the `zest` prop such as `onTextChanged`, `parser`, `validator`, and the `formatter` / `templater` functions within `helperTextConfig` are susceptible to this. If they are not memoized, `ZestTextbox`'s internal logic will constantly detect these as "new" properties, leading to continuous state updates and excessive re-renders.

**The Solution: Memoize Your Function Props**

You must ensure that any function you pass to `ZestTextbox`'s `zest` prop (or any other function-type prop if added in the future) has a stable reference across renders. 

> **Note:** As of v0.4.18, `onTextChanged` is internally stabilized using `useRef`. This means passing an unmemoized function to `onTextChanged` will no longer cause infinite re-render loops or performance degradation. However, memoizing it (and all other function props) is still considered a best practice for optimal performance and to avoid unnecessary internal state reconciliations.

### For Functional Components (Recommended for new development)

Use the `useCallback` hook to memoize your functions.

```jsx
import React, { useState, useCallback } from 'react';
import ZestTextbox, { InputParser, InputValidator } from 'jattac.libs.web.zest-textbox';

const MyFunctionalComponent = () => {
  const [value, setValue] = useState('');
  const [parsedNum, setParsedNum] = useState<number | undefined>(undefined);

  // Memoize onTextChanged
  const handleTextChanged = useCallback((newValue: string) => {
    setValue(newValue);
    // Any logic that depends on `value` or other state/props should be in the dependencies array.
  }, []); // Empty dependency array means this function is created once.

  // Memoize custom parser and validator
  const customParser = useCallback<InputParser<number>>((val) => {
    return parseInt(val, 10) || undefined;
  }, []);

  const customValidator = useCallback<InputValidator<number>>((num) => {
    if (num === undefined) return "Please enter a valid number.";
    return num > 0 ? true : "Number must be positive.";
  }, []);

  return (
    <div>
      <ZestTextbox
        placeholder="Type here..."
        onTextChanged={handleTextChanged} // Stable reference
        zest={{
          parser: customParser,       // Stable reference
          validator: customValidator, // Stable reference
          // ... other zest props
        }}
      />
      <p>Current Value: {value}</p>
      <p>Parsed Number: {parsedNum}</p>
    </div>
  );
};

export default MyFunctionalComponent;
```
**Important:** Ensure the dependency array for `useCallback` is correct. If your callback uses state or props, include them in the dependency array. If the dependencies themselves are unstable, `useCallback` won't prevent the function from being recreated.

### For Class Components

Define your callback functions as class methods. Using arrow functions for class methods automatically binds `this` and provides a stable reference across renders.

```jsx
import React from 'react';
import ZestTextbox from 'jattac.libs.web.zest-textbox';

class MyClassComponent extends React.Component {
  state = {
    inputValue: '',
    parsedValue: undefined,
  };

  // Define as a class property using an arrow function for stable reference and auto-binding
  handleTextChanged = (newValue) => {
    this.setState({ inputValue: newValue });
  };

  // Example of a custom parser method
  myParser = (val) => {
    return val ? parseInt(val, 10) : undefined;
  };

  render() {
    return (
      <div>
        <ZestTextbox
          placeholder="Enter text (class component)"
          onTextChanged={this.handleTextChanged} // Stable reference
          zest={{
            parser: this.myParser, // Stable reference
            // ... other zest props
          }}
        />
        <p>Current Input: {this.state.inputValue}</p>
      </div>
    );
  }
}

export default MyClassComponent;
```

**Function Props that Require Memoization:**

The following `ZestTextbox` properties are functions or contain functions and should be memoized by the consumer to ensure optimal performance and prevent re-renders:

*   `onTextChanged` (top-level prop)
*   `zest.parser`
*   `zest.validator`
*   `zest.helperTextConfig.formatter`
*   `zest.helperTextConfig.templater`

---

## Server-Side Rendering (SSR) and Client-Side Execution in Next.js

`ZestTextbox` is designed to be fully compatible with Server-Side Rendering (SSR) frameworks like Next.js. However, certain browser-specific APIs can cause issues if not handled correctly.

**The Problem: `window` and `document` Access on the Server**

When a Next.js application is rendered on the server, global browser objects such as `window`, `document`, and `navigator` are not available. Any attempt to access these directly in the global scope or during the initial server render phase of a component will result in a `ReferenceError` and can cause your application to crash or fail to build.

**How `ZestTextbox` Handles It Internally:**

`ZestTextbox` internally handles this by guarding access to browser-specific APIs within its hooks. For example, the `useThemeDetector` hook, which relies on `window.matchMedia`, includes checks to ensure this code only runs in a client-side environment:

```typescript
// Inside useThemeDetector.ts
useEffect(() => {
  // Only run this effect on the client-side
  if (typeof window === 'undefined') {
    return;
  }
  // ... browser-specific code ...
}, []);
```

**Best Practices for Consumers in Next.js:**

If your components or custom hooks have client-side-only logic that directly accesses browser globals:

1.  **Guard `window`/`document` Access:** Wrap any browser-specific code within `typeof window !== 'undefined'` checks or ensure it runs only inside `useEffect` hooks.
2.  **Dynamic Imports for Client Components:** For larger components that are purely client-side and rely heavily on browser APIs, use Next.js's `dynamic` import with `ssr: false`:

    ```jsx
    import dynamic from 'next/dynamic';

    const ClientOnlyComponent = dynamic(
      () => import('../components/ClientOnlyComponent'),
      { ssr: false } // This component will only be rendered on the client side
    );

    const MyPage = () => {
      return (
        <div>
          <h1>My Page</h1>
          <ClientOnlyComponent />
        </div>
      );
    };
    ```
3.  **"use client" Directive:** For App Router components in Next.js, ensure you mark components that rely on client-side features with the `"use client"` directive at the top of the file. Note that this directive applies to the component and its children, effectively making them part of the client bundle.

---

## Integrating with Next.js App Router: Global Configuration

Configuring `ZestTextbox` globally using `ZestTextboxConfigProvider` in a Next.js App Router environment requires careful placement due to the distinction between Server Components and Client Components. Context Providers are inherently client-side, as they typically involve state management that cannot be executed on the server.

**The Strategy:**

To ensure your `ZestTextboxConfigProvider` is accessible throughout your application while respecting Next.js's rendering model, you need to:

1.  **Create a dedicated Client Component** to wrap your context providers. This component will be marked with the `"use client"` directive.
2.  **Import this Client Component** into your root `layout.tsx`.

**Implementation Steps:**

### Step 1: Create a `providers.tsx` (or similar) Client Component

Create a file (e.g., `app/providers.tsx` or `src/app/providers.tsx`) that will contain your `ZestTextboxConfigProvider`.

```tsx
// app/providers.tsx or src/app/providers.tsx
"use client"; // This directive is crucial! It marks this as a Client Component.

import React from 'react';
import { ZestTextboxConfigProvider } from 'jattac.libs.web.zest-textbox';
// Import other client-side context providers if you have them

// Define your global ZestTextbox configuration here.
// Remember to memoize any function definitions within `globalZestConfig`
// to prevent unnecessary re-renders.
const globalZestConfig = {
  // Example: Default theme for all ZestTextboxes
  theme: "system",
  // Example: All textboxes stretch by default
  stretch: true,
  // Example: Custom parser for a specific inputType used globally
  parser: (value, inputType) => {
    if (inputType === 'custom-id') {
      // Your custom parsing logic here
      return value.toUpperCase();
    }
    return value;
  },
  // ... other global ZestProps
};

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <ZestTextboxConfigProvider value={globalZestConfig}>
      {children}
    </ZestTextboxConfigProvider>
  );
}
```

### Step 2: Import `Providers` into your Root `layout.tsx`

Your root `layout.tsx` (e.g., `app/layout.tsx`) is a Server Component by default. You will import the `Providers` Client Component and use it to wrap your application's `children`.

```tsx
// app/layout.tsx or src/app/layout.tsx
import './globals.css'; // Your global styles

// Import your client-side providers wrapper
import { Providers } from './providers'; // Adjust path as needed

export default function RootLayout({
  children,
}: {
  children: React.ReactNode;
}) {
  return (
    <html lang="en">
      <body>
        {/* Wrap your application content with the Providers component */}
        <Providers>
          {children}
        </Providers>
      </body>
    </html>
  );
}
```

**Why this works:**

This pattern allows your `layout.tsx` to remain a Server Component, benefiting from SSR, while correctly offloading the client-side context provider to a Client Component (`providers.tsx`). This ensures `ZestTextboxConfigProvider` initializes in the appropriate environment, making its global configuration available to all client components within your application without causing SSR errors.

---

## General Component Optimization Tips

*   **`React.memo` (for consumer components):** If your parent component re-renders frequently and passes the same props to `ZestTextbox` (or any other child component), wrap your parent component or intermediate components with `React.memo` to prevent unnecessary re-renders of the child. `ZestTextbox` internally leverages memoization where appropriate, but outer components benefit from this too.
*   **Avoid Expensive Calculations in Render:** Keep your `render` methods and functional component bodies as lean as possible. Move expensive calculations into `useMemo` or `useCallback`.

---

[‚¨ÖÔ∏è Previous: Contributor's Guide](./development.md) | [Next: Upgrade Path ‚û°Ô∏è](./breaking-changes.md)
