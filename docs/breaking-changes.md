<!-- docs/breaking-changes.md -->
[⬅️ Previous: Contributor's Guide](./development.md)

# ⚠️ Breaking Changes

This document outlines significant changes between versions of `ZestTextbox` that may require modifications to your codebase when upgrading. Each entry includes the affected version, a description of the change, and a clear migration guide with "Before" and "After" code examples.

---

## Table of Contents
<!-- TOC auto-generated by Gemini CLI, please do not edit -->
<!-- TOC END -->

---

## Version 0.1.7 - Encapsulation of Custom Props into `zest` Object

**Description:**
To improve API clarity, consistency, and enable advanced configuration patterns (such as [Centralized Configuration](./configuration.md) and `ZestConfigValue`), all custom props (`isMultiline`, `zSize`, `stretch`, `theme`, `animatedCounter`, `showProgressBar`, `onTextChanged`, `helperTextConfig`, `parser`, `validator`, `helperTextPositioning`) have been removed as top-level props from the `ZestTextbox` component. They are now consolidated and encapsulated within a single `zest` object prop.

**Migration Guide:**

If you were previously using custom `ZestTextbox` properties directly on the component:

```jsx
// Before Version 0.1.7
import React from 'react';
import ZestTextbox from 'jattac.libs.web.zest-textbox';

const OldComponent = () => {
  return (
    <ZestTextbox
      isMultiline
      zSize="lg"
      theme="dark"
      onTextChanged={(value) => console.log(value)}
      maxLength={100}
      showProgressBar
    />
  );
};
```

You should now wrap these properties within the `zest` prop:

```jsx
// After Version 0.1.7
import React from 'react';
import ZestTextbox from 'jattac.libs.web.zest-textbox';

const NewComponent = () => {
  return (
    <ZestTextbox
      maxLength={100} // maxLength remains a top-level HTML attribute
      zest={{
        isMultiline: true,
        zSize: "lg",
        theme: "dark",
        onTextChanged: (value) => console.log(value),
        showProgressBar: true,
      }}
    />
  );
};
```

---

## Version 0.4.18 - Stable and Complete `onTextChanged` Behavior

**Description:**
The `onTextChanged` callback has been significantly improved for stability and completeness. It now:
1.  **Stops infinite re-render loops:** Internally stabilized using `useRef`; it no longer triggers effects when the function reference changes.
2.  **Reports invalid states:** Fires with `undefined` when the input fails validation. Previously, it would simply stop firing, making it difficult for parents to track invalid states.
3.  **Includes a Value-Change Guard:** Only fires when the *parsed* value actually changes (using deep equality).
4.  **Skips initial mount:** The callback no longer fires immediately upon component mounting, only on subsequent user-initiated or external value changes.

**Migration Guide:**

If your logic relied on `onTextChanged` *only* firing for valid inputs, you should now add a check for `undefined`:

```jsx
// Before Version 0.4.18
const handleTextChanged = (parsedValue) => {
  // Only called when valid
  setMyState(parsedValue);
};

// After Version 0.4.18
const handleTextChanged = (parsedValue) => {
  if (parsedValue === undefined) {
    // Input is invalid! Handle appropriately (e.g., disable submit)
    setIsValid(false);
    return;
  }
  setIsValid(true);
  setMyState(parsedValue);
};
```

---

[⬅️ Previous: Best Practices](./best-practices.md) | [Next: README.md (Back to Top) ➡️](../README.md)
